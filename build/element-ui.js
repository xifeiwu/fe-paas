const fs = require('fs');
const path = require('path');
const util = require('util');
const endOfLine = require('os').EOL;
const {execSync} = require('child_process');
const render = require('json-templater/string');
const uppercamelcase = require('uppercamelcase');
const webpackConfig = require('./webpack.base.conf');
const promisifyReadFile = util.promisify(fs.readFile);

const DIR_ASSETS = webpackConfig['resolve']['alias']['assets'];
const DIR_ELEMENT_SRC = webpackConfig['resolve']['alias']['element-ui'];
const DIR_ELEMENT_OUTPUT = path.resolve(DIR_ASSETS, 'static/components/ele');

class PreBuilder {
  constructor() {
  }

  async readConfig(configName) {
    const commentReg = /^ *\/\/.*/;
    const content = (await promisifyReadFile(path.resolve(DIR_ELEMENT_OUTPUT, `${configName}.json`))).toString()
      .split('\n').filter(it => {
        return !commentReg.exec(it);
      }).join('\n');
    // console.log(JSON.parse(content))
    return JSON.parse(content);
  }

  deleteFolderRecursive(path) {
    if (fs.existsSync(path)) {
      fs.readdirSync(path).forEach((file, index) => {
        var curPath = path + "/" + file;
        if (fs.lstatSync(curPath).isDirectory()) { // recurse
          this.deleteFolderRecursive(curPath);
        } else { // delete file
          fs.unlinkSync(curPath);
        }
      });
      fs.rmdirSync(path);
    }
  };

  async generateJs(configName) {
    const components = await this.readConfig(configName);

    const OUTPUT_PATH = path.resolve(DIR_ELEMENT_OUTPUT, `${configName}.js`);
    const IMPORT_TEMPLATE = 'import {{name}} from \'element-ui/packages/{{package}}/index.js\';';
    const INSTALL_COMPONENT_TEMPLATE = '  {{name}}';
    const MAIN_TEMPLATE = `/* Automatically generated by './build/bin/build-entry.js' */

{{include}}
// import locale from 'element-ui/src/locale';
import CollapseTransition from 'element-ui/src/transitions/collapse-transition';

const components = [
{{install}},
  CollapseTransition
];

const install = function(Vue, opts = {}) {
  // locale.use(opts.locale);
  // locale.i18n(opts.i18n);

  components.forEach(component => {
    Vue.component(component.name, component);
  });

  Vue.use(Loading.directive);

  Vue.prototype.$ELEMENT = {
    size: opts.size || '',
    zIndex: opts.zIndex || 2000
  };

  Vue.prototype.$loading = Loading.service;
  Vue.prototype.$msgbox = MessageBox;
  Vue.prototype.$alert = MessageBox.alert;
  Vue.prototype.$confirm = MessageBox.confirm;
  Vue.prototype.$prompt = MessageBox.prompt;
  Vue.prototype.$notify = Notification;
  Vue.prototype.$message = Message;

};

/* istanbul ignore if */
if (typeof window !== 'undefined' && window.Vue) {
  install(window.Vue);
}

module.exports = {
  version: '{{version}}',
  // locale: locale.use,
  // i18n: locale.i18n,
  install,
  CollapseTransition,
  Loading,
{{list}}
};

module.exports.default = module.exports;
`;

    delete components.font;

    var ComponentNames = Object.keys(components);

    var includeComponentTemplate = [];
    var installTemplate = [];
    var listTemplate = [];

    ComponentNames.forEach(name => {
      var componentName = uppercamelcase(name);

      includeComponentTemplate.push(render(IMPORT_TEMPLATE, {
        name: componentName,
        package: name
      }));

      if (['Loading', 'MessageBox', 'Notification', 'Message'].indexOf(componentName) === -1) {
        installTemplate.push(render(INSTALL_COMPONENT_TEMPLATE, {
          name: componentName,
          component: name
        }));
      }

      if (componentName !== 'Loading') listTemplate.push(`  ${componentName}`);
    });

    var template = render(MAIN_TEMPLATE, {
      include: includeComponentTemplate.join(endOfLine),
      install: installTemplate.join(',' + endOfLine),
      version: '1.0.0',
      list: listTemplate.join(',' + endOfLine)
    });

    fs.writeFileSync(OUTPUT_PATH, template);
    console.log('[build entry] DONE:', OUTPUT_PATH);
  }

  async generateCss(configName) {
    const components = await this.readConfig(configName);
    const componentName = Object.keys(components);
    var themes = [
      'theme-chalk'
    ];
    const BASE_PATH = path.resolve(DIR_ELEMENT_SRC, 'packages');


    themes.forEach(async (theme) => {
      const THEME_DIR = path.resolve(BASE_PATH, theme);
      // var isSCSS = theme !== 'theme-default';
      const isSCSS = true;

      var indexContent = isSCSS ? '@import "./base.scss";\n' : '@import "./base.css";\n';
      componentName.forEach(function(key) {
        if (['icon', 'option', 'option-group'].indexOf(key) > -1) return;
        var fileName = key + (isSCSS ? '.scss' : '.css');
        indexContent += '@import "./' + fileName + '";\n';
        var filePath = path.resolve(THEME_DIR, 'src', fileName);
        if (!fs.existsSync(filePath)) {
          // fs.writeFileSync(filePath, '', 'utf8');
          console.log(theme, ' 创建遗漏的 ', fileName, ' 文件');
        }
      });

      // generate custom scss for configName
      fs.writeFileSync(path.resolve(THEME_DIR, 'src', isSCSS ? `${configName}.scss` : `${configName}.css`), indexContent);
      // build scss
      console.log(execSync(`gulp build --gulpfile ${path.resolve(THEME_DIR, 'gulpfile.js')}`, { encoding: 'utf-8' }));
      // copy scss
      const outputDir = path.resolve(DIR_ELEMENT_OUTPUT, `${theme}`);
      if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, '0744');
      }
      const sourceDir = path.resolve(THEME_DIR, 'lib');
      console.log(execSync(`cp -r ${sourceDir}/* ${outputDir}`, { encoding: 'utf-8' }));
      this.deleteFolderRecursive(sourceDir);
    });
  }
}

const preBuilder = new PreBuilder();
// preBuilder.readConfig('profile');
preBuilder.generateJs('profile');
preBuilder.generateCss('profile');